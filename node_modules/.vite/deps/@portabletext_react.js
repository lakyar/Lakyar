import {
  require_jsx_runtime
} from "./chunk-JD2GUPID.js";
import {
  require_react
} from "./chunk-6ZBOOF7O.js";
import {
  __toESM
} from "./chunk-5WRI5ZAA.js";

// node_modules/@portabletext/react/dist/index.js
var import_jsx_runtime = __toESM(require_jsx_runtime());

// node_modules/@portabletext/toolkit/dist/index.js
function isPortableTextSpan(node) {
  return node._type === "span" && "text" in node && typeof node.text == "string" && (node.marks === void 0 || Array.isArray(node.marks) && node.marks.every((mark) => typeof mark == "string"));
}
function isPortableTextBlock(node) {
  return typeof node._type == "string" && node._type[0] !== "@" && (!("markDefs" in node) || !node.markDefs || Array.isArray(node.markDefs) && node.markDefs.every((def) => typeof def._key == "string")) && "children" in node && Array.isArray(node.children) && node.children.every((child) => typeof child == "object" && "_type" in child);
}
function isPortableTextListItemBlock(block) {
  return isPortableTextBlock(block) && "listItem" in block && typeof block.listItem == "string" && (block.level === void 0 || typeof block.level == "number");
}
function isPortableTextToolkitList(block) {
  return block._type === "@list";
}
function isPortableTextToolkitSpan(span) {
  return span._type === "@span";
}
function isPortableTextToolkitTextNode(node) {
  return node._type === "@text";
}
var knownDecorators = [
  "strong",
  "em",
  "code",
  "underline",
  "strike-through"
];
function sortMarksByOccurences(span, index, blockChildren) {
  if (!isPortableTextSpan(span) || !span.marks || !span.marks.length) return [];
  let marks = span.marks.slice(), occurences = {};
  return marks.forEach((mark) => {
    occurences[mark] = 1;
    for (let siblingIndex = index + 1; siblingIndex < blockChildren.length; siblingIndex++) {
      let sibling = blockChildren[siblingIndex];
      if (sibling && isPortableTextSpan(sibling) && Array.isArray(sibling.marks) && sibling.marks.indexOf(mark) !== -1) occurences[mark]++;
      else break;
    }
  }), marks.sort((markA, markB) => sortMarks(occurences, markA, markB));
}
function sortMarks(occurences, markA, markB) {
  let aOccurences = occurences[markA], bOccurences = occurences[markB];
  if (aOccurences !== bOccurences) return bOccurences - aOccurences;
  let aKnownPos = knownDecorators.indexOf(markA), bKnownPos = knownDecorators.indexOf(markB);
  return aKnownPos === bKnownPos ? markA.localeCompare(markB) : aKnownPos - bKnownPos;
}
function buildMarksTree(block) {
  let { children } = block, markDefs = block.markDefs ?? [];
  if (!children || !children.length) return [];
  let sortedMarks = children.map(sortMarksByOccurences), rootNode = {
    _type: "@span",
    children: [],
    markType: "<unknown>"
  }, nodeStack = [rootNode];
  for (let i = 0; i < children.length; i++) {
    let span = children[i];
    if (!span) continue;
    let marksNeeded = sortedMarks[i] || [], pos = 1;
    if (nodeStack.length > 1) for (; pos < nodeStack.length; pos++) {
      let mark = nodeStack[pos]?.markKey || "", index = marksNeeded.indexOf(mark);
      if (index === -1) break;
      marksNeeded.splice(index, 1);
    }
    nodeStack = nodeStack.slice(0, pos);
    let currentNode = nodeStack[nodeStack.length - 1];
    if (currentNode) {
      for (let markKey of marksNeeded) {
        let markDef = markDefs?.find((def) => def._key === markKey), node = {
          _type: "@span",
          _key: span._key,
          children: [],
          markDef,
          markType: markDef ? markDef._type : markKey,
          markKey
        };
        currentNode.children.push(node), nodeStack.push(node), currentNode = node;
      }
      if (isPortableTextSpan(span)) {
        let lines = span.text.split("\n");
        for (let line = lines.length; line-- > 1; ) lines.splice(line, 0, "\n");
        currentNode.children = currentNode.children.concat(lines.map((text) => ({
          _type: "@text",
          text
        })));
      } else currentNode.children = currentNode.children.concat(span);
    }
  }
  return rootNode.children;
}
function nestLists(blocks, mode) {
  let tree = [], currentList;
  for (let i = 0; i < blocks.length; i++) {
    let block = blocks[i];
    if (block) {
      if (!isPortableTextListItemBlock(block)) {
        tree.push(block), currentList = void 0;
        continue;
      }
      if (!currentList) {
        currentList = listFromBlock(block, i, mode), tree.push(currentList);
        continue;
      }
      if (blockMatchesList(block, currentList)) {
        currentList.children.push(block);
        continue;
      }
      if ((block.level || 1) > currentList.level) {
        let newList = listFromBlock(block, i, mode);
        if (mode === "html") {
          let lastListItem = currentList.children[currentList.children.length - 1], newLastChild = {
            ...lastListItem,
            children: [...lastListItem.children, newList]
          };
          currentList.children[currentList.children.length - 1] = newLastChild;
        } else currentList.children.push(newList);
        currentList = newList;
        continue;
      }
      if ((block.level || 1) < currentList.level) {
        let matchingBranch = tree[tree.length - 1], match = matchingBranch && findListMatching(matchingBranch, block);
        if (match) {
          currentList = match, currentList.children.push(block);
          continue;
        }
        currentList = listFromBlock(block, i, mode), tree.push(currentList);
        continue;
      }
      if (block.listItem !== currentList.listItem) {
        let matchingBranch = tree[tree.length - 1], match = matchingBranch && findListMatching(matchingBranch, { level: block.level || 1 });
        if (match && match.listItem === block.listItem) {
          currentList = match, currentList.children.push(block);
          continue;
        } else {
          currentList = listFromBlock(block, i, mode), tree.push(currentList);
          continue;
        }
      }
      console.warn("Unknown state encountered for block", block), tree.push(block);
    }
  }
  return tree;
}
function blockMatchesList(block, list) {
  return (block.level || 1) === list.level && block.listItem === list.listItem;
}
function listFromBlock(block, index, mode) {
  return {
    _type: "@list",
    _key: `${block._key || `${index}`}-parent`,
    mode,
    level: block.level || 1,
    listItem: block.listItem,
    children: [block]
  };
}
function findListMatching(rootNode, matching) {
  let level = matching.level || 1, style = matching.listItem || "normal", filterOnType = typeof matching.listItem == "string";
  if (isPortableTextToolkitList(rootNode) && (rootNode.level || 1) === level && filterOnType && (rootNode.listItem || "normal") === style) return rootNode;
  if (!("children" in rootNode)) return;
  let node = rootNode.children[rootNode.children.length - 1];
  return node && !isPortableTextSpan(node) ? findListMatching(node, matching) : void 0;
}
function spanToPlainText(span) {
  let text = "";
  return span.children.forEach((current) => {
    isPortableTextToolkitTextNode(current) ? text += current.text : isPortableTextToolkitSpan(current) && (text += spanToPlainText(current));
  }), text;
}
var leadingSpace = /^\s/;
var trailingSpace = /\s$/;
function toPlainText(block) {
  let blocks = Array.isArray(block) ? block : [block], text = "";
  return blocks.forEach((current, index) => {
    if (!isPortableTextBlock(current)) return;
    let pad = false;
    current.children.forEach((span) => {
      isPortableTextSpan(span) ? (text += pad && text && !trailingSpace.test(text) && !leadingSpace.test(span.text) ? " " : "", text += span.text, pad = false) : pad = true;
    }), index !== blocks.length - 1 && (text += "\n\n");
  }), text;
}
var LIST_NEST_MODE_HTML = "html";

// node_modules/@portabletext/react/dist/index.js
var import_react = __toESM(require_react());
var defaultLists = {
  number: ({ children }) => (0, import_jsx_runtime.jsx)("ol", { children }),
  bullet: ({ children }) => (0, import_jsx_runtime.jsx)("ul", { children })
};
var DefaultListItem = ({ children }) => (0, import_jsx_runtime.jsx)("li", { children });
var link = ({ children, value }) => (0, import_jsx_runtime.jsx)("a", {
  href: value?.href,
  children
});
var underlineStyle = { textDecoration: "underline" };
var defaultMarks = {
  em: ({ children }) => (0, import_jsx_runtime.jsx)("em", { children }),
  strong: ({ children }) => (0, import_jsx_runtime.jsx)("strong", { children }),
  code: ({ children }) => (0, import_jsx_runtime.jsx)("code", { children }),
  underline: ({ children }) => (0, import_jsx_runtime.jsx)("span", {
    style: underlineStyle,
    children
  }),
  "strike-through": ({ children }) => (0, import_jsx_runtime.jsx)("del", { children }),
  link
};
var getTemplate = (type, prop) => `[@portabletext/react] Unknown ${type}, specify a component for it in the \`components.${prop}\` prop`;
var unknownTypeWarning = (typeName) => getTemplate(`block type "${typeName}"`, "types");
var unknownMarkWarning = (markType) => getTemplate(`mark type "${markType}"`, "marks");
var unknownBlockStyleWarning = (blockStyle) => getTemplate(`block style "${blockStyle}"`, "block");
var unknownListStyleWarning = (listStyle) => getTemplate(`list style "${listStyle}"`, "list");
var unknownListItemStyleWarning = (listStyle) => getTemplate(`list item style "${listStyle}"`, "listItem");
function printWarning(message) {
  console.warn(message);
}
var hidden = { display: "none" };
var defaultComponents = {
  types: {},
  block: {
    normal: ({ children }) => (0, import_jsx_runtime.jsx)("p", { children }),
    blockquote: ({ children }) => (0, import_jsx_runtime.jsx)("blockquote", { children }),
    h1: ({ children }) => (0, import_jsx_runtime.jsx)("h1", { children }),
    h2: ({ children }) => (0, import_jsx_runtime.jsx)("h2", { children }),
    h3: ({ children }) => (0, import_jsx_runtime.jsx)("h3", { children }),
    h4: ({ children }) => (0, import_jsx_runtime.jsx)("h4", { children }),
    h5: ({ children }) => (0, import_jsx_runtime.jsx)("h5", { children }),
    h6: ({ children }) => (0, import_jsx_runtime.jsx)("h6", { children })
  },
  marks: defaultMarks,
  list: defaultLists,
  listItem: DefaultListItem,
  hardBreak: () => (0, import_jsx_runtime.jsx)("br", {}),
  unknownType: ({ value, isInline }) => {
    let warning = unknownTypeWarning(value._type);
    return (0, import_jsx_runtime.jsx)(isInline ? "span" : "div", {
      style: hidden,
      children: warning
    });
  },
  unknownMark: ({ markType, children }) => (0, import_jsx_runtime.jsx)("span", {
    className: `unknown__pt__mark__${markType}`,
    children
  }),
  unknownList: ({ children }) => (0, import_jsx_runtime.jsx)("ul", { children }),
  unknownListItem: ({ children }) => (0, import_jsx_runtime.jsx)("li", { children }),
  unknownBlockStyle: ({ children }) => (0, import_jsx_runtime.jsx)("p", { children })
};
function mergeComponents(parent, overrides) {
  let { block: _block, list: _list, listItem: _listItem, marks: _marks, types: _types, ...rest } = overrides;
  return {
    ...parent,
    block: mergeDeeply(parent, overrides, "block"),
    list: mergeDeeply(parent, overrides, "list"),
    listItem: mergeDeeply(parent, overrides, "listItem"),
    marks: mergeDeeply(parent, overrides, "marks"),
    types: mergeDeeply(parent, overrides, "types"),
    ...rest
  };
}
function mergeDeeply(parent, overrides, key) {
  let override = overrides[key], parentVal = parent[key];
  return typeof override == "function" || override && typeof parentVal == "function" ? override : override ? {
    ...parentVal,
    ...override
  } : parentVal;
}
function PortableText({ value: input, components: componentOverrides, listNestingMode, onMissingComponent: missingComponentHandler = printWarning }) {
  let handleMissingComponent = missingComponentHandler || noop, nested = nestLists(Array.isArray(input) ? input : [input], listNestingMode || LIST_NEST_MODE_HTML), components = (0, import_react.useMemo)(() => componentOverrides ? mergeComponents(defaultComponents, componentOverrides) : defaultComponents, [componentOverrides]), renderNode = (0, import_react.useMemo)(() => getNodeRenderer(components, handleMissingComponent), [components, handleMissingComponent]);
  return (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, { children: nested.map((node, index) => renderNode({
    node,
    index,
    isInline: false,
    renderNode
  })) });
}
var getNodeRenderer = (components, handleMissingComponent) => {
  function renderNode(options) {
    let { node, index, isInline } = options, key = node._key || `node-${index}`;
    return isPortableTextToolkitList(node) ? renderList(node, index, key) : isPortableTextListItemBlock(node) ? renderListItem(node, index, key) : isPortableTextToolkitSpan(node) ? renderSpan(node, index, key) : hasCustomComponentForNode(node) ? renderCustomBlock(node, index, key, isInline) : isPortableTextBlock(node) ? renderBlock(node, index, key, isInline) : isPortableTextToolkitTextNode(node) ? renderText(node, key) : renderUnknownType(node, index, key, isInline);
  }
  function hasCustomComponentForNode(node) {
    return node._type in components.types;
  }
  function renderListItem(node, index, key) {
    let tree = serializeBlock({
      node,
      index,
      isInline: false,
      renderNode
    }), renderer = components.listItem, Li = (typeof renderer == "function" ? renderer : renderer[node.listItem]) || components.unknownListItem;
    if (Li === components.unknownListItem) {
      let style = node.listItem || "bullet";
      handleMissingComponent(unknownListItemStyleWarning(style), {
        type: style,
        nodeType: "listItemStyle"
      });
    }
    let children = tree.children;
    if (node.style && node.style !== "normal") {
      let { listItem: _listItem, ...blockNode } = node;
      children = renderNode({
        node: blockNode,
        index,
        isInline: false,
        renderNode
      });
    }
    return (0, import_jsx_runtime.jsx)(Li, {
      value: node,
      index,
      isInline: false,
      renderNode,
      children
    }, key);
  }
  function renderList(node, index, key) {
    let children = node.children.map((child, childIndex) => renderNode({
      node: child._key ? child : {
        ...child,
        _key: `li-${index}-${childIndex}`
      },
      index: childIndex,
      isInline: false,
      renderNode
    })), component = components.list, List = (typeof component == "function" ? component : component[node.listItem]) || components.unknownList;
    if (List === components.unknownList) {
      let style = node.listItem || "bullet";
      handleMissingComponent(unknownListStyleWarning(style), {
        nodeType: "listStyle",
        type: style
      });
    }
    return (0, import_jsx_runtime.jsx)(List, {
      value: node,
      index,
      isInline: false,
      renderNode,
      children
    }, key);
  }
  function renderSpan(node, _index, key) {
    let { markDef, markType, markKey } = node, Span = components.marks[markType] || components.unknownMark, children = node.children.map((child, childIndex) => renderNode({
      node: child,
      index: childIndex,
      isInline: true,
      renderNode
    }));
    return Span === components.unknownMark && handleMissingComponent(unknownMarkWarning(markType), {
      nodeType: "mark",
      type: markType
    }), (0, import_jsx_runtime.jsx)(Span, {
      text: spanToPlainText(node),
      value: markDef,
      markType,
      markKey,
      renderNode,
      children
    }, key);
  }
  function renderBlock(node, index, key, isInline) {
    let { _key, ...props } = serializeBlock({
      node,
      index,
      isInline,
      renderNode
    }), style = props.node.style || "normal", Block = (typeof components.block == "function" ? components.block : components.block[style]) || components.unknownBlockStyle;
    return Block === components.unknownBlockStyle && handleMissingComponent(unknownBlockStyleWarning(style), {
      nodeType: "blockStyle",
      type: style
    }), (0, import_jsx_runtime.jsx)(Block, {
      ...props,
      value: props.node,
      renderNode
    }, key);
  }
  function renderText(node, key) {
    if (node.text === "\n") {
      let HardBreak = components.hardBreak;
      return HardBreak ? (0, import_jsx_runtime.jsx)(HardBreak, {}, key) : "\n";
    }
    return node.text;
  }
  function renderUnknownType(node, index, key, isInline) {
    let nodeOptions = {
      value: node,
      isInline,
      index,
      renderNode
    };
    handleMissingComponent(unknownTypeWarning(node._type), {
      nodeType: "block",
      type: node._type
    });
    let UnknownType = components.unknownType;
    return (0, import_jsx_runtime.jsx)(UnknownType, { ...nodeOptions }, key);
  }
  function renderCustomBlock(node, index, key, isInline) {
    let nodeOptions = {
      value: node,
      isInline,
      index,
      renderNode
    }, Node = components.types[node._type];
    return Node ? (0, import_jsx_runtime.jsx)(Node, { ...nodeOptions }, key) : null;
  }
  return renderNode;
};
function serializeBlock(options) {
  let { node, index, isInline, renderNode } = options, children = buildMarksTree(node).map((child, i) => renderNode({
    node: child,
    isInline: true,
    index: i,
    renderNode
  }));
  return {
    _key: node._key || `block-${index}`,
    children,
    index,
    isInline,
    node
  };
}
function noop() {
}
export {
  PortableText,
  defaultComponents,
  mergeComponents,
  toPlainText
};
//# sourceMappingURL=@portabletext_react.js.map
